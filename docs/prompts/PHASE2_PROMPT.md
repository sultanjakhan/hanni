# Phase 2: Module → Functions — Function Decomposition (per module)

> **Модуль:** [MODULE_NAME]
> **Входной документ:** `docs/architecture/[module]/[module].md` (вики модуля, если есть)
> **Входной Phase 1:** `docs/MODULE_MAP.md` + `docs/architecture/COVERAGE.md`
> **Трекер:** `docs/architecture/COVERAGE.md`
> **Диспуты:** `docs/architecture/DISPUTED.md`
> **Цель:** Перечитать ВСЕ файлы/секции модуля, разбить на функции, создать индекс функций.

---

## Контекст

Phase 2 — второй шаг иерархии **Проект → Модули → Функции → Подфункции**.
Phase 1 уже определил модули и привязал файлы/секции.
Этот промпт **декомпозирует один модуль** на отдельные бизнес-функции.

**Запускается для каждого модуля отдельно.**

**Что такое «функция» в Phase 2:**
- Это НЕ программная функция (`fn`, `function`), а **бизнес-функция** — единица функциональности
- Примеры: "Авторизация через Google OAuth", "Создание события в календаре", "Голосовой ввод (Whisper)"
- Одна бизнес-функция может включать несколько программных функций, endpoint'ов, компонентов
- Granularity: 5-30 строк → часть функции, 30-200 строк → одна функция, 200+ → несколько функций

---

## ШАГ 0: Загрузка контекста

### 0.1 — Прочитай MODULE_MAP.md

Открой `docs/MODULE_MAP.md`. Найди секцию модуля `[MODULE_NAME]`:
- Какие файлы/секции принадлежат модулю?
- Какие диапазоны строк (для monolithic файлов)?

Запиши → `MODULE_FILES[]`

### 0.2 — Прочитай вики модуля (если есть)

Если существует `docs/architecture/[module]/[module].md`:
- Прочитай текущее описание
- Выпиши список файлов из вики → `WIKI_FILES[]`
- Сравни с `MODULE_FILES[]` — несовпадения запиши

Если вики нет → будет создана на шаге 5.

### 0.3 — Прочитай COVERAGE.md

Открой `docs/architecture/COVERAGE.md`. Запиши текущее состояние модуля:
- Статус Phase 2 для этого модуля
- Количество файлов/секций и LOC

### 0.4 — Прочитай DISPUTED.md

Проверь записи, связанные с текущим модулем. Если проблема решена → отметь `[RESOLVED]`.

---

## ШАГ 1: Полное чтение кода модуля

### 1.1 — Прочитай КАЖДЫЙ файл/секцию модуля

Для каждого элемента из `MODULE_FILES[]`:

1. **Посчитай строки** (`wc -l`) → точное число
2. **Прочитай код полностью** (по частям, если > 500 строк)
3. **Зафиксируй:**
   - Все экспортируемые символы (функции, классы, типы, константы)
   - Все endpoint'ы / route'ы (если backend)
   - Все компоненты / view'ы (если frontend)
   - Все Tauri-команды / IPC-вызовы (если desktop)
   - Импорты из НАШИХ файлов (не из библиотек)
   - Кто импортирует этот файл (через grep)

### 1.2 — Дополнительный поиск файлов

Ищи файлы, которые Phase 1 мог пропустить:

```bash
# По ключевым словам модуля
grep -rl "[keyword1]\|[keyword2]" [source_dirs] --include="*.rs" --include="*.js" | sort

# По импортам из файлов модуля
grep -rl "from.*[module_file]\|use.*[module_crate]" [source_dirs] | sort
```

Новые найденные файлы → `NEW_FILES[]`.

### 1.3 — Сверка списков

```markdown
| # | Файл/секция | В MODULE_MAP? | В grep? | В вики? | Действие |
|---|-------------|---------------|---------|---------|----------|
| 1 | ... | ✅ | ✅ | ✅ | Проверить |
| 2 | ... | ❌ | ✅ | ❌ | НОВЫЙ → добавить или → DISPUTED |
| 3 | ... | ✅ | ❌ | ✅ | УДАЛЁН? → проверить |
```

**Правило:** Ни один файл/секция не пропускается.

---

## ШАГ 2: Разбивка на бизнес-функции

### Принцип группировки

Группируй код в бизнес-функции по принципу:
- **Один use-case** = одна функция (e.g., "Пользователь создаёт событие")
- **Один CRUD-набор** может быть одной функцией, если они простые
- **Сложная логика** (>100 строк) = отдельная функция даже без endpoint'а

### 2.1 — Backend Functions (B)

Для каждого endpoint'а или серверной логики:

| # | Функция | Тип | Endpoint/Entry | Файл:строки | LOC | Cmplx | Audit |
|---|---------|-----|----------------|-------------|-----|-------|-------|
| B1 | Авторизация через OAuth | endpoint | `GET /api/auth/google` | lib.rs:L100-L180 | 81 | Medium | ⬜ |
| B2 | Запоминание факта | endpoint | `POST /api/memory` | lib.rs:L200-L250 | 51 | Simple | ⬜ |
| B3 | Миграция БД | internal | init_db() | lib.rs:L50-L99 | 50 | Complex | ⬜ |

**Типы:**
- `endpoint` — обрабатывает HTTP/IPC запрос
- `internal` — внутренняя логика (не вызывается извне напрямую)
- `scheduled` — запускается по расписанию (cron, timer)
- `event` — реакция на событие (websocket, callback)

### 2.2 — Frontend Functions (F)

Для каждого UI-компонента или view:

| # | Компонент/View | Route/Trigger | Файл:строки | LOC | Cmplx | Audit |
|---|---------------|---------------|-------------|-----|-------|-------|
| F1 | Chat View | Tab: Chat | main.js:L50-L500 | 451 | Complex | ⬜ |
| F2 | Settings Panel | Tab: Settings | main.js:L3000-L3200 | 201 | Medium | ⬜ |

### 2.3 — Integration Functions (I)

Для связей между backend и frontend, или с внешними сервисами:

| # | Интеграция | Направление | Backend entry | Frontend entry | LOC | Cmplx | Audit |
|---|-----------|-------------|---------------|----------------|-----|-------|-------|
| I1 | Streaming chat | FE→BE→FE | chat_inner() | streamResponse() | 200 | Complex | ⬜ |
| I2 | TTS через edge-tts | BE→External | speak_edge_tts() | — | 50 | Simple | ⬜ |

### 2.4 — Complexity Assessment

| Complexity | LOC | Критерии |
|------------|-----|----------|
| Simple | <50 | Прямой CRUD, нет ветвлений, нет внешних вызовов |
| Medium | 50-150 | Есть валидация, условная логика, 1-2 зависимости |
| Complex | >150 | Многоступенчатая логика, streaming, state machine, >3 зависимостей |

---

## ШАГ 3: Проверка мёртвого кода и спорных элементов

### 3.1 — Мёртвый код

Для каждого экспортируемого символа модуля:

```bash
# Проверь: кто-то использует этот символ?
grep -r "[symbol_name]" [source_dirs] --include="*.rs" --include="*.js" | grep -v "^.*:.*\(export\|pub\|fn \)[[:space:]]"
```

Если 0 результатов → мёртвый код → DISPUTED.md с grep output.

### 3.2 — Спорные функции

Функции, которые логически принадлежат другому модулю:
- Определи по вызовам: если функция в модуле X, но вызывается только из модуля Y → спорная
- Запиши в DISPUTED.md "Спорные элементы"

### 3.3 — Недостающая функциональность

Что ожидаешь увидеть в этом модуле, но не нашёл?
- Запиши в DISPUTED.md "Кандидаты на рефакторинг"

---

## ШАГ 4: Обновление трекеров

### 4.1 — COVERAGE.md

1. Обнови статус модуля: `Phase 2: ✅ done`
2. Обнови кол-во функций: `B+I+F = [total]`
3. Добавь новые файлы/секции (из Шага 1.2)
4. Пересчитай TOTAL
5. **Проверка суммы:** `сумма элементов по модулям + unassigned = total`

### 4.2 — MODULE_MAP.md

1. Добавь новые файлы/секции
2. Исправь диапазоны строк, если изменились
3. Обнови LOC модуля

### 4.3 — DISPUTED.md

1. Добавь новые записи из Шага 3
2. Проверь старые записи текущего модуля → `[RESOLVED]` если решены
3. Обнови нумерацию

---

## ШАГ 5: Создание документации модуля

### 5.1 — Вики модуля

Создай/обнови `docs/architecture/[module]/[module].md`:

```markdown
# Модуль: [MODULE_NAME]

> [Описание модуля в 1-2 предложениях]

## Обзор

| Метрика | Значение |
|---------|----------|
| Файлов/секций | [X] |
| LOC | [Y] |
| Функций (B+I+F) | [a]+[b]+[c]=[N] |
| Complexity | [Simple: X, Medium: Y, Complex: Z] |

## Файлы модуля

| # | Файл | Секция (если monolith) | LOC | Описание |
|---|------|----------------------|-----|----------|
| 1 | ... | ... | ... | ... |

## Зависимости

### Использует (imports from):
- `[module_B]`: [что именно]
- `[external_lib]`: [для чего]

### Используется (imported by):
- `[module_C]`: [что берёт]

## Env Variables (если есть)

| Переменная | Описание | Значение по умолчанию |
|-----------|----------|----------------------|

## Известные проблемы

→ См. `docs/architecture/DISPUTED.md` (секция [MODULE_NAME])
```

### 5.2 — Индекс функций

Создай `docs/architecture/[module]/functions.md`:

```markdown
# [MODULE_NAME] — Индекс функций

> Все бизнес-функции модуля. Audit = ⬜ до Phase 3.

## Backend Functions

| # | Функция | Тип | Endpoint/Entry | Файл:строки | LOC | Cmplx | Audit |
|---|---------|-----|----------------|-------------|-----|-------|-------|
| B1 | ... | ... | ... | ... | ... | ... | ⬜ |

## Frontend Functions

| # | Компонент/View | Route/Trigger | Файл:строки | LOC | Cmplx | Audit |
|---|---------------|---------------|-------------|-----|-------|-------|
| F1 | ... | ... | ... | ... | ... | ⬜ |

## Integration Functions

| # | Интеграция | Направление | Backend entry | Frontend entry | LOC | Cmplx | Audit |
|---|-----------|-------------|---------------|----------------|-----|-------|-------|
| I1 | ... | ... | ... | ... | ... | ... | ⬜ |

## Сводка

| Тип | Кол-во | Simple | Medium | Complex |
|-----|--------|--------|--------|---------|
| Backend (B) | [X] | [a] | [b] | [c] |
| Frontend (F) | [Y] | [d] | [e] | [f] |
| Integration (I) | [Z] | [g] | [h] | [i] |
| **TOTAL** | **[N]** | **[S]** | **[M]** | **[C]** |
```

---

## ПРАВИЛА

1. **`wc -l` / чтение перед описанием.** Не пиши про файл/секцию, пока не прочитал.
2. **Точные строки.** `wc -l`, не "~". Диапазоны `L100-L250`, не "около строки 100".
3. **grep для подтверждения.** Мёртвый код / спорные = grep output обязателен.
4. **Всё спорное → DISPUTED.md.** Не замалчивать.
5. **COVERAGE.md обновляется КАЖДЫЙ прогон.**
6. **Проверка суммы обязательна.**
7. **Бизнес-функция, не программная.** `create_event + validate_event + save_event` = одна бизнес-функция "Создание события", а не три.
8. **Не дробить мелко.** Если CRUD укладывается в 50 строк → одна функция, не четыре.
9. **Не объединять крупно.** Если endpoint >200 строк или содержит разную логику → отдельные функции.

---

## ВЫХОДНЫЕ ФАЙЛЫ

```
docs/
├── MODULE_MAP.md                     — обновлён
└── architecture/
    ├── COVERAGE.md                   — обновлён (Phase 2 статус модуля)
    ├── DISPUTED.md                   — дополнен
    └── [module]/
        ├── [module].md               — вики модуля (создано/обновлено)
        └── functions.md              — индекс функций (Audit = ⬜)
```

---

## ПОСЛЕ ЗАВЕРШЕНИЯ

Покажи:

1. **Таблицу функций** (компактно: ID, имя, тип, complexity)
2. **Счётчик:** `[MODULE]: [F] элементов, [S] LOC, B[X]+I[Y]+F[Z]=[N] функций`
3. **Complexity breakdown:** `Simple: [a], Medium: [b], Complex: [c]`
4. **Coverage:** `[Y]/[X] элементов распределено ([P]%)`
5. **DISPUTED:** сколько новых записей
6. **Контрольная сумма:** `сумма элементов по модулям + unassigned = total` ✅/❌

Спроси:
- "Все функции разбиты правильно? Хочешь объединить/разбить?"
- "Переходить к Phase 2 для модуля [NEXT] или Phase 3 (аудит) для [CURRENT]?"
